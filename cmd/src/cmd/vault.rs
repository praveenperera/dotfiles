use eyre::Result;
use xshell::Shell;

use crate::{encrypt, util::handle_xflags_error};

mod flags {
    xflags::xflags! {
        src "./src/cmd/vault.rs"

        cmd vault {
            /// Encrypt file
            cmd encrypt enc {
                required file: String
            }

            /// Decrypt file
            cmd decrypt dec {
                required file: String
            }
        }
    }

    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Vault {
        pub subcommand: VaultCmd,
    }

    #[derive(Debug)]
    pub enum VaultCmd {
        Encrypt(Encrypt),
        Decrypt(Decrypt),
    }

    #[derive(Debug)]
    pub struct Encrypt {
        pub file: String,
    }

    #[derive(Debug)]
    pub struct Decrypt {
        pub file: String,
    }

    impl Vault {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end

    impl Vault {
        pub fn help() -> &'static str {
            Self::HELP_
        }
    }
}

static DEFAULT_SECRET_HEADER: &str = "!!CMD!!ID!!vault-default";

pub fn run(sh: &Shell, args: &[&str]) -> Result<()> {
    let os_args = args
        .iter()
        .map(|s| std::ffi::OsString::from(*s))
        .collect::<Vec<_>>();

    let flags = handle_xflags_error(flags::Vault::from_vec(os_args), args, flags::Vault::help())?;

    match flags.subcommand {
        flags::VaultCmd::Encrypt(cmd) => {
            encrypt(sh, &cmd.file)?;
        }
        flags::VaultCmd::Decrypt(cmd) => {
            decrypt(sh, &cmd.file)?;
        }
    }

    Ok(())
}

fn encrypt(sh: &Shell, file: &str) -> Result<()> {
    let output = format!("{file}.enc");

    if !sh.path_exists(&output) {
        sh.write_file(&output, DEFAULT_SECRET_HEADER)?;
    }

    encrypt::encrypt(sh, file, &output)?;
    Ok(())
}

fn decrypt(sh: &Shell, file: &str) -> Result<()> {
    let output = file.trim_end_matches(".enc");

    if file == output {
        return Err(eyre::eyre!("file does not end with .enc"));
    }

    encrypt::decrypt(sh, file, output)?;

    Ok(())
}
