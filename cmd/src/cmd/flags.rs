use crate::util::handle_xflags_error;

xflags::xflags! {
    src "./src/cmd/flags.rs"

    cmd cmd {
        /// Print version information
        optional --version

        /// Bootstrap dotfiles
        cmd bootstrap {
            repeated args: String
        }

        /// Release/update cmd binary
        cmd release {
            optional args: String
        }

        /// Configure dotfiles (alias: cfg)
        cmd config cfg {
            optional args: String
        }

        /// Google Cloud operations
        cmd gcloud {
            repeated args: String
        }

        /// Secret operations
        cmd secret {
            repeated args: String
        }

        /// Terraform (alias: tf)
        cmd terraform tf {
            repeated args: String
        }

        /// Vault operations
        cmd vault {
            repeated args: String
        }

        /// Generate code/files (alias: gen)
        cmd generate gen {
            repeated args: String
        }
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Cmd {
    pub version: bool,
    pub subcommand: CmdCmd,
}

#[derive(Debug)]
pub enum CmdCmd {
    Bootstrap(Bootstrap),
    Release(Release),
    Config(Config),
    Gcloud(Gcloud),
    Secret(Secret),
    Terraform(Terraform),
    Vault(Vault),
    Generate(Generate),
}

#[derive(Debug)]
pub struct Bootstrap {
    pub args: Vec<String>,
}

#[derive(Debug)]
pub struct Release {
    pub args: Option<String>,
}

#[derive(Debug)]
pub struct Config {
    pub args: Option<String>,
}

#[derive(Debug)]
pub struct Gcloud {
    pub args: Vec<String>,
}

#[derive(Debug)]
pub struct Secret {
    pub args: Vec<String>,
}

#[derive(Debug)]
pub struct Terraform {
    pub args: Vec<String>,
}

#[derive(Debug)]
pub struct Vault {
    pub args: Vec<String>,
}

#[derive(Debug)]
pub struct Generate {
    pub args: Vec<String>,
}

impl Cmd {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end

impl Cmd {
    pub fn help() -> &'static str {
        Cmd::HELP_
    }

    pub fn from_args(args: &[std::ffi::OsString]) -> eyre::Result<Self> {
        handle_xflags_error(Cmd::from_vec(args.to_vec()), args, Cmd::help())
    }
}

impl Bootstrap {
    pub fn help(&self) -> &'static str {
        crate::cmd::bootstrap::flags::Bootstrap::help()
    }
}

impl Release {
    pub fn help(&self) -> &'static str {
        "run with no args"
    }
}

impl Config {
    pub fn help(&self) -> &'static str {
        "run with no args"
    }
}

impl Gcloud {
    pub fn help(&self) -> &'static str {
        crate::cmd::gcloud::flags::Gcloud::help()
    }
}

impl Secret {
    pub fn help(&self) -> &'static str {
        crate::util::VAULT
    }
}

impl Terraform {
    pub fn help(&self) -> &'static str {
        "run with subcommands"
    }
}

impl Vault {
    pub fn help(&self) -> &'static str {
        "run with args"
    }
}

impl Generate {
    pub fn help(&self) -> &'static str {
        ""
    }
}
