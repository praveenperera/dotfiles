use std::{path::Path, process::Command};

use eyre::{Context as _, ContextCompat as _, Result};
use log::debug;
use sha2::Digest;
use xshell::Shell;

use crate::{encrypt, util::handle_xflags_error};

mod flags {
    xflags::xflags! {
        src "./src/cmd/terraform.rs"

        cmd terraform {
            /// Initialize terraform state
            cmd init {
                repeated args: String
            }

            /// Encrypt terraform state file
            cmd encrypt enc {
                optional file: String
            }

            /// Decrypt terraform state file
            cmd decrypt dec {
                optional file: String
            }

            /// Run terraform command
            default cmd run {
                required command: String
                repeated args: String
            }
        }
    }

    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Terraform {
        pub subcommand: TerraformCmd,
    }

    #[derive(Debug)]
    pub enum TerraformCmd {
        Run(Run),
        Init(Init),
        Encrypt(Encrypt),
        Decrypt(Decrypt),
    }

    #[derive(Debug)]
    pub struct Run {
        pub command: String,
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Init {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Encrypt {
        pub file: Option<String>,
    }

    #[derive(Debug)]
    pub struct Decrypt {
        pub file: Option<String>,
    }

    impl Terraform {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end

    impl Terraform {
        pub fn help() -> &'static str {
            Self::HELP_
        }
    }
}

pub fn run(sh: &Shell, args: &[&str]) -> Result<()> {
    debug!("terraform args: {args:?}");

    let os_args = args
        .iter()
        .map(|s| std::ffi::OsString::from(*s))
        .collect::<Vec<_>>();

    let flags = handle_xflags_error(flags::Terraform::from_vec(os_args), args, flags::Terraform::help())?;

    match flags.subcommand {
        flags::TerraformCmd::Init(cmd) => {
            let args: Vec<&str> = cmd.args.iter().map(|s| s.as_str()).collect();
            init(sh, &args)?;
        }
        flags::TerraformCmd::Encrypt(cmd) => {
            let file = cmd.file.as_deref().unwrap_or("terraform.tfstate");
            encrypt(sh, file)?;
        }
        flags::TerraformCmd::Decrypt(cmd) => {
            let file = cmd.file.as_deref().unwrap_or("terraform.tfstate.enc");
            decrypt(sh, file)?;
        }
        flags::TerraformCmd::Run(cmd) => {
            let args: Vec<&str> = cmd.args.iter().map(|s| s.as_str()).collect();
            run_terraform_cmd(sh, &cmd.command, &args)?;
        }
    }

    Ok(())
}

fn init(sh: &Shell, _args: &[&str]) -> Result<()> {
    if sh.path_exists("terraform.tfstate.enc") {
        eprintln!("terraform.tfstate.enc already exists");
    } else {
        eprintln!("terraform.tfstate.enc does not exist, creating...");
        encrypt::create_secret_and_files(sh, "terraform-state-pw", "terraform.tfstate.enc")?;
    }

    let terraform_state = encrypt::read_encrypted_file("terraform.tfstate.enc")?;

    if terraform_state.is_empty() {
        eprintln!("terraform.tfstate.enc is empty");
    } else {
        eprintln!("terraform.tfstate.enc is not empty");
    }

    run_terraform_cmd(sh, "init", &[])?;

    Ok(())
}

fn run_terraform_cmd(sh: &Shell, cmd: &str, args: &[&str]) -> Result<()> {
    let tmpdir = tempfile::tempdir()?;
    let tfstate = tmpdir.path().join("terraform.tfstate");

    let tfstate = tfstate
        .to_str()
        .wrap_err("could not convert path to string")?;

    encrypt::encrypt(sh, "terraform.tfstate.enc", tfstate)?;
    let before_hash = sha2::Sha256::digest(sh.read_file(tfstate)?);

    // use command instead of xshell because to deal with interactive prompts
    let result = Command::new("terraform")
        .arg(cmd)
        .arg("-state")
        .arg(tfstate)
        .args(args)
        .spawn()
        .wrap_err("could not spawn terraform")?
        .wait()
        .wrap_err("could not wait for terraform")?;

    if !result.success() {
        sh.remove_path(tfstate)?;
        return Err(eyre::eyre!("terraform {cmd} failed"));
    };

    let after_hash = sha2::Sha256::digest(sh.read_file(tfstate)?);
    if before_hash != after_hash {
        encrypt::encrypt(sh, tfstate, "terraform.tfstate.enc")?;

        let tfstate_parent = Path::new(tfstate)
            .parent()
            .wrap_err("could not get parent of input file")?;

        sh.remove_path(tfstate_parent)?;

        let tfstate = tfstate_parent.join("terraform.tfstate");
        let tfstate_backup = tfstate.join("terraform.tfstate.backup");

        sh.remove_path(tfstate_backup)?;
        sh.remove_path(tfstate)?;
    }

    sh.remove_path(tfstate)?;

    Ok(())
}

fn encrypt(sh: &Shell, input_file: &str) -> Result<()> {
    init(sh, &[])?;
    let output_file = Path::new(input_file).with_extension("enc").to_path_buf();
    encrypt::encrypt(sh, input_file, output_file.to_string_lossy().as_ref())
}

fn decrypt(sh: &Shell, input_file: &str) -> Result<()> {
    let output_file = if input_file.ends_with(".enc") {
        input_file.trim_end_matches(".enc").to_string()
    } else {
        input_file.to_string() + ".dec"
    };

    encrypt::decrypt(sh, input_file, &output_file)
}
