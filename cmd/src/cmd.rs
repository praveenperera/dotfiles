pub mod bootstrap;
pub mod gcloud;
pub mod generate;
pub mod secrets;
pub mod terraform;
pub mod vault;

use colored::Colorize as _;
use eyre::{eyre, Result};
use log::debug;
use xshell::Shell;

use crate::util::{did_you_mean, handle_xflags_error};
use flags::{Cmd, CmdCmd};

mod flags {
    xflags::xflags! {
        src "./src/cmd.rs"

        cmd cmd {
            /// Print version information
            optional --version

            /// Bootstrap dotfiles
            cmd bootstrap {
                repeated args: String
            }

            /// Release/update cmd binary
            cmd release {
                repeated args: String
            }

            /// Configure dotfiles (alias: cfg)
            cmd config cfg {
                repeated args: String
            }

            /// Google Cloud login (alias: gl)
            cmd gcloud-login gl {
                repeated args: String
            }

            /// Google Cloud switch project (alias: gsp)
            cmd gcloud-switch-project gsp {
                repeated args: String
            }

            /// Google Cloud switch cluster (alias: gsc)
            cmd gcloud-switch-cluster gsc {
                repeated args: String
            }

            /// Generate secret (aliases: secret-generate, sgen)
            cmd secret-gen secret-generate sgen {
                repeated args: String
            }

            /// Get secret (alias: sg)
            cmd secret-get sg {
                repeated args: String
            }

            /// Save secret (alias: ss)
            cmd secret-save ss {
                repeated args: String
            }

            /// Update secret (alias: su)
            cmd secret-update su {
                repeated args: String
            }

            /// Terraform (alias: tf)
            cmd terraform tf {
                repeated args: String
            }

            /// Vault operations
            cmd vault {
                repeated args: String
            }

            /// Generate code/files (alias: gen)
            cmd generate gen {
                repeated args: String
            }
        }
    }

    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Cmd {
        pub version: bool,
        pub subcommand: CmdCmd,
    }

    #[derive(Debug)]
    pub enum CmdCmd {
        Bootstrap(Bootstrap),
        Release(Release),
        Config(Config),
        GcloudLogin(GcloudLogin),
        GcloudSwitchProject(GcloudSwitchProject),
        GcloudSwitchCluster(GcloudSwitchCluster),
        SecretGen(SecretGen),
        SecretGet(SecretGet),
        SecretSave(SecretSave),
        SecretUpdate(SecretUpdate),
        Terraform(Terraform),
        Vault(Vault),
        Generate(Generate),
    }

    #[derive(Debug)]
    pub struct Bootstrap {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Release {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Config {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudLogin {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudSwitchProject {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudSwitchCluster {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretGen {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretGet {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretSave {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretUpdate {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Terraform {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Vault {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Generate {
        pub args: Vec<String>,
    }

    impl Cmd {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end
    //
    impl Cmd {
        pub fn help() -> &'static str {
            Cmd::HELP_
        }
    }
}

pub fn run(_sh: &Shell, args: &[&str]) -> Result<()> {
    debug!("cmd run args: {args:?}");

    // convert args to Vec<OsString> for xflags parsing
    let os_args = args
        .iter()
        .map(|s| std::ffi::OsString::from(*s))
        .collect::<Vec<_>>();

    let flags = match Cmd::from_vec(os_args) {
        Ok(flags) => flags,
        Err(_err) => {
            let unknown_cmd = crate::util::extract_unknown_command_from_args(args);
            match unknown_cmd.as_deref() {
                Some("help" | "-h" | "--help") => {
                    println!("{}", Cmd::help());
                    return Ok(());
                }

                Some(unknown_cmd) => {
                    let suggestions = did_you_mean(unknown_cmd, Cmd::help());
                    if !suggestions.is_empty() {
                        println!("\ndid you mean: {}\n", suggestions.join(", ").yellow());
                    }

                    println!("{}", Cmd::help());
                    return Err(eyre!("failed to parse arguments"));
                }
                None => {
                    println!("{}", Cmd::help());
                    return Err(eyre!("failed to parse arguments"));
                }
            }
        }
    };

    if flags.version {
        println!("{}", env!("CARGO_PKG_VERSION"));
        return Ok(());
    }

    let sh = Shell::new()?;
    match flags.subcommand {
        CmdCmd::Bootstrap(cmd) => bootstrap::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Release(cmd) => bootstrap::release(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Config(cmd) => bootstrap::config(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::GcloudLogin(cmd) => gcloud::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::GcloudSwitchProject(cmd) => gcloud::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::GcloudSwitchCluster(cmd) => gcloud::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::SecretGen(cmd) => secrets::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::SecretGet(cmd) => secrets::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::SecretSave(cmd) => secrets::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::SecretUpdate(cmd) => secrets::run(&sh, &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>()),
        CmdCmd::Terraform(cmd) => terraform::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Vault(cmd) => vault::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Generate(cmd) => generate::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
    }
}
