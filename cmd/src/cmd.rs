pub mod bootstrap;
pub mod gcloud;
pub mod generate;
pub mod secrets;
pub mod terraform;
pub mod vault;

use colored::Colorize as _;
use eyre::{eyre, Result};
use log::debug;
use xshell::Shell;

use flags::{Cmd, CmdCmd};

mod flags {
    xflags::xflags! {
        src "./src/cmd.rs"

        cmd cmd {
            /// Print version information
            optional --version

            /// Bootstrap dotfiles
            cmd bootstrap {
                repeated args: String
            }

            /// Release/update cmd binary
            cmd release {
                repeated args: String
            }

            /// Configure dotfiles (alias: cfg)
            cmd config cfg {
                repeated args: String
            }

            /// Google Cloud login (alias: gl)
            cmd gcloud-login gl {
                repeated args: String
            }

            /// Google Cloud switch project (alias: gsp)
            cmd gcloud-switch-project gsp {
                repeated args: String
            }

            /// Google Cloud switch cluster (alias: gsc)
            cmd gcloud-switch-cluster gsc {
                repeated args: String
            }

            /// Generate secret (aliases: secret-generate, sgen)
            cmd secret-gen secret-generate sgen {
                repeated args: String
            }

            /// Get secret (alias: sg)
            cmd secret-get sg {
                repeated args: String
            }

            /// Save secret (alias: ss)
            cmd secret-save ss {
                repeated args: String
            }

            /// Update secret (alias: su)
            cmd secret-update su {
                repeated args: String
            }

            /// Terraform (alias: tf)
            cmd terraform tf {
                repeated args: String
            }

            /// Vault operations
            cmd vault {
                repeated args: String
            }

            /// Generate code/files (alias: gen)
            cmd generate gen {
                repeated args: String
            }
        }
    }

    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Cmd {
        pub version: bool,
        pub subcommand: CmdCmd,
    }

    #[derive(Debug)]
    pub enum CmdCmd {
        Bootstrap(Bootstrap),
        Release(Release),
        Config(Config),
        GcloudLogin(GcloudLogin),
        GcloudSwitchProject(GcloudSwitchProject),
        GcloudSwitchCluster(GcloudSwitchCluster),
        SecretGen(SecretGen),
        SecretGet(SecretGet),
        SecretSave(SecretSave),
        SecretUpdate(SecretUpdate),
        Terraform(Terraform),
        Vault(Vault),
        Generate(Generate),
    }

    #[derive(Debug)]
    pub struct Bootstrap {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Release {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Config {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudLogin {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudSwitchProject {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct GcloudSwitchCluster {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretGen {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretGet {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretSave {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct SecretUpdate {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Terraform {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Vault {
        pub args: Vec<String>,
    }

    #[derive(Debug)]
    pub struct Generate {
        pub args: Vec<String>,
    }

    impl Cmd {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end
    //
    impl Cmd {
        pub fn help() -> &'static str {
            Cmd::HELP_
        }
    }
}

pub fn run(_sh: &Shell, args: &[&str]) -> Result<()> {
    debug!("cmd run args: {args:?}");

    // convert args to Vec<OsString> for xflags parsing
    let os_args = args
        .iter()
        .map(|s| std::ffi::OsString::from(*s))
        .collect::<Vec<_>>();

    let flags = match Cmd::from_vec(os_args) {
        Ok(flags) => flags,
        Err(_err) => {
            let unknown_cmd = extract_unknown_command_from_args(args);
            match unknown_cmd.as_deref() {
                Some("help" | "-h" | "--help") => {
                    println!("{}", Cmd::help());
                    return Ok(());
                }

                Some(unknown_cmd) => {
                    let suggestions = did_you_mean(&unknown_cmd);
                    if !suggestions.is_empty() {
                        println!("\ndid you mean: {}\n", suggestions.join(", ").yellow());
                    }

                    println!("{}", Cmd::help());
                    return Err(eyre!("failed to parse arguments"));
                }
                None => {
                    println!("{}", Cmd::help());
                    return Err(eyre!("failed to parse arguments"));
                }
            }
        }
    };

    if flags.version {
        println!("{}", env!("CARGO_PKG_VERSION"));
        return Ok(());
    }

    let sh = Shell::new()?;
    match flags.subcommand {
        CmdCmd::Bootstrap(cmd) => bootstrap::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Release(cmd) => bootstrap::release(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Config(cmd) => bootstrap::config(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::GcloudLogin(cmd) => gcloud::login(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::GcloudSwitchProject(cmd) => gcloud::switch_project(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::GcloudSwitchCluster(cmd) => gcloud::switch_cluster(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::SecretGen(cmd) => secrets::gen(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::SecretGet(cmd) => secrets::get(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::SecretSave(cmd) => secrets::save(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::SecretUpdate(cmd) => secrets::update(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Terraform(cmd) => terraform::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Vault(cmd) => vault::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
        CmdCmd::Generate(cmd) => generate::run(
            &sh,
            &cmd.args.iter().map(|s| s.as_str()).collect::<Vec<_>>(),
        ),
    }
}

fn extract_unknown_command_from_args(args: &[&str]) -> Option<String> {
    // get the first argument which should be the subcommand
    args.first().map(|s| s.to_string())
}

fn extract_commands_from_help() -> Vec<String> {
    let help_text = flags::Cmd::help();
    let mut commands = Vec::new();

    // parse the help text to extract subcommands
    // look for lines that start with spaces followed by command names
    for line in help_text.lines() {
        let trimmed = line.trim_start();
        if line.starts_with("  ") && !line.starts_with("   ") && !trimmed.starts_with('-') {
            // this looks like a command line (starts with 2 spaces, not 3+, not a flag)
            if let Some(command) = trimmed.split_whitespace().next() {
                // extract the main command name and any aliases
                if command.contains(',') {
                    // handle commands with aliases like "config, cfg"
                    for cmd in command.split(',') {
                        let cmd = cmd.trim();
                        if !cmd.is_empty() {
                            commands.push(cmd.to_string());
                        }
                    }
                } else {
                    commands.push(command.to_string());
                }
            }
        }
    }

    commands.sort();
    commands.dedup();
    commands
}

fn did_you_mean(user_text: &str) -> Vec<&str> {
    use textdistance::nstr::damerau_levenshtein;

    // get available commands from xflags help text
    static AVAILABLE_COMMANDS: std::sync::OnceLock<Vec<String>> = std::sync::OnceLock::new();
    let available_commands = AVAILABLE_COMMANDS.get_or_init(extract_commands_from_help);

    let mut suggestions = available_commands
        .iter()
        .filter(|name| !name.starts_with(user_text))
        .map(|name| (name.as_str(), damerau_levenshtein(user_text, name)))
        .map(|(name, distance)| (name, distance * 100.0))
        .map(|(name, distance)| (name, distance as usize))
        .filter(|(_, distance)| *distance <= 90)
        .collect::<Vec<_>>();

    suggestions.sort_unstable_by(|a, b| a.1.cmp(&b.1));

    let starts_with: Vec<&str> = available_commands
        .iter()
        .map(|s| s.as_str())
        .filter(|name| name.starts_with(user_text))
        .collect();

    let suggestions: Vec<&str> = suggestions
        .into_iter()
        .map(|(name, _)| name)
        .take(3)
        .collect();

    starts_with.into_iter().chain(suggestions).collect()
}
