{"type":"user","timestamp":"2025-12-17T20:48:23.142Z","content":"@document-writer read @2025/12-15-passkey-prf-bitcoin-wallet-backup.md and tell me what you think\nUse the above message and context to generate a prompt and call the task tool with subagent: document-writer\nCalled the Read tool with the following input: {\"filePath\":\"/Users/praveen/code/praveen/posts/2025/12-15-passkey-prf-bitcoin-wallet-backup.md\"}\n<file>\n00001| ==title==\n00002| A New Approach to Universal Bitcoin Wallet Backup with Passkeys and PRF\n00003| \n00004| ==author==\n00005| Praveen Perera\n00006| \n00007| ==tags==\n00008| bitcoin, security, passkeys, webauthn, prf, cove\n00009| \n00010| ==description==\n00011| A proposal for cross-platform Bitcoin wallet backup using WebAuthn PRF, no passwords, no server trust\n00012| \n00013| ==updated_at==\n00014| 2025-12-17\n00015| \n00016| ==body==\n00017| I've been building [Cove](https://covebitcoinwallet.com), a Bitcoin wallet focused on making self-custody accessible. We launched with the standard approach: show users their 12/24 words, tell them to write it down somewhere safe. But Cove is supposed to be beginner-friendly, and for users just getting started with a hot wallet, keeping those words secure and not losing them is a major source of anxiety.\n00018| \n00019| I've wanted to add automatic cloud backup for a while, but I hadn't found a solution I loved. After researching existing approaches and working through the tradeoffs, I designed an architecture using the WebAuthn PRF (Pseudo-Random Function) extension combined with untrusted cloud storage. PRF lets us derive an encryption key from a passkey, so we can store encrypted data in iCloud or Google Drive without having to trust Apple or Google. This post outlines a proposal for a universal backup mechanism that any wallet can implement.\n00020| \n00021| I'm working with [Tankred Hase](https://x.com/tankredhase) to develop this into a proper specification. I'm building this for Cove, and Tankred is interested in implementing it in [StashPay](https://stashpay.me/). The goal is to prove the concept works across different wallets and platforms before formalizing the spec.\n00022| \n00023| ## Table of Contents\n00024| \n00025| - [Existing Cloud Backup Solutions](#existing-cloud-backup-solutions) - Phoenix, Kraken, Bull Bitcoin\n00026| - [Why Not iCloud Keychain Directly?](#why-not-icloud-keychain-directly) - The verification problem\n00027| - [Enter WebAuthn PRF](#enter-webauthn-prf) - How PRF works\n00028| - [The Architecture](#the-architecture) - Setup and restore flow\n00029| - [Platform Support](#platform-support) - iOS 18.4+, Android 9+\n00030| - [Proposed Implementation](#proposed-implementation) - Data structures and formats\n00031| - [Security Considerations](#security-considerations) - Caveats and risks\n00032| - [What's Next](#whats-next) - Formal specification\n00033| - [Feedback](#feedback) - Get in touch\n00034| \n00035| ## Existing Cloud Backup Solutions {: #existing-cloud-backup-solutions}\n00036| \n00037| Before starting work on Cove's backup, I looked at a few existing iCloud backup implementations.\n00038| \n00039| ### Phoenix Wallet\n00040| \n00041| [Phoenix](https://phoenix.acinq.co/) was the first wallet where I really liked the backup UX. Automatic, invisible, just works.\n00042| \n00043| Looking into their implementation, they use [CloudKit](https://developer.apple.com/icloud/cloudkit/) with `encryptedValues`<sup>[[1]]</sup>. The problem is that CloudKit is not end-to-end encrypted by default<sup>[[2]]</sup>. It requires the user to enable [Advanced Data Protection](https://support.apple.com/en-us/102651) (ADP), which most users don't know about. Without ADP, Apple can technically access the data.\n00044| \n00045| I like that Phoenix includes a disclaimer explaining this to users. And honestly, this is probably an acceptable trade-off for most people using a hot wallet, Apple rugging you isn't in most people's threat models. But I wanted to see if there was something better.\n00046| \n00047| ### Kraken Wallet\n00048| \n00049| [Kraken Wallet](https://www.kraken.com/wallet) took a different approach using passkeys. What I liked was that it's a fully end-to-end encrypted solution. They use the WebAuthn `largeBlob` extension to store the encrypted seed directly inside the passkey.\n00050| \n00051| But looking deeper, I found some limitations:\n00052| \n00053| - **iOS only** - Android doesn't support largeBlob<sup>[[3]]</sup>\n00054| - **Single seed** - They store a single master seed and derive multiple accounts using standard BIP32 paths, which means you can't backup imported wallets\n00055| - **iCloud Keychain only** - When I tried it, it didn't work because I use 1Password. To get Kraken's passkey backup working, I would have had to disable 1Password as my global password manager. PRF, on the other hand, is supported by third-party password managers including [1Password](https://1password.com/blog/encrypt-data-saved-passkeys) and [Bitwarden](https://bitwarden.com/blog/prf-webauthn-and-its-role-in-passkeys/).\n00056| \n00057| More fundamentally, Kraken's approach stores the encrypted seed _inside_ the passkey credential itself using largeBlob. The approach I'm proposing uses the passkey only to derive an encryption key; the encrypted data lives separately in cloud storage. This decoupled architecture removes the size limitations and enables Android support.\n00058| \n00059| ### Bull Bitcoin (Recoverbull)\n00060| \n00061| While I was working on this, Bull Bitcoin released [Recoverbull](https://www.bullbitcoin.com/blog/recoverbull-a-bitcoin-wallet-backup-system), based on the Photon spec with a key server. I thought it was elegant, but I didn't want to go with it because of the requirement to run a key server. I didn't want to be responsible for maintaining that infrastructure.\n00062| \n00063| All of these made smart tradeoffs for their use cases. But I wanted something cross-platform, no server to maintain, and supports arbitrary wallet imports.\n00064| \n00065| ## Why Not iCloud Keychain Directly? {: #why-not-icloud-keychain-directly}\n00066| \n00067| While looking into Phoenix and Kraken, I noticed that Kraken was using iCloud Keychain for their passkeys. That's when I started wondering, why aren't people just using iCloud Keychain directly? Store the seed with `kSecAttrSynchronizable = true`, let Apple sync it. Done.\n00068| \n00069| This is where Tankred Hase comes in. Tankred created [Photon SDK](https://github.com/photon-sdk/photon-lib), an open-source library for seedless wallet backups (which Recoverbull is based on), so I reached out to get his perspective on my approach.\n00070| \n00071| He pointed out a critical flaw, there's no API to verify if a Keychain item actually synced to iCloud. A user could have iCloud Keychain disabled, or syncing could fail silently. They'd think their wallet is backed up when it isn't. That's how people lose Bitcoin.\n00072| \n00073| I had initially planned to use iCloud Keychain on iOS and Google Block Store on Android. I already knew Google Block Store had no verification API (you can't tell if the user has backup enabled). Tankred pointed out iCloud Keychain has the same problem. That explained why people weren't just using iCloud Keychain directly.\n00074| \n00075| I told Tankred I was already thinking about using PRF for Android since it works with Google Password Manager. Maybe I could just use PRF for both iOS and Android? Passkeys solve the verification problem because they're always synced through the platform's password manager by design, not device-specific like Keychain items.\n00076| \n00077| ## Enter WebAuthn PRF {: #enter-webauthn-prf}\n00078| \n00079| The [PRF extension](https://w3c.github.io/webauthn/#prf-extension) is a relatively new addition to WebAuthn. It lets you derive a deterministic 32-byte secret from a passkey authentication.\n00080| \n00081| Here's what makes it interesting:\n00082| \n00083| - **Deterministic** - `PRF(passkey, salt)` always produces the same output\n00084| - **Requires authentication** - User must complete biometric/PIN each time\n00085| - **Hardware-backed** - The PRF secret never leaves the secure element\n00086| - **Phishing-resistant** - Bound to the relying party origin\n00087| \n00088| The output is essentially [`HMAC-SHA256(device_secret, salt)`](https://developers.yubico.com/WebAuthn/Concepts/PRF_Extension/CTAP2_HMAC_Secret_Deep_Dive.html). You get a cryptographically strong 32-byte key that's reproducible, protected by biometrics, and never transmitted over the network.\n00089| \n00090| To my knowledge, this is the first proposed specification for cross-platform Bitcoin wallet backup using PRF.\n00091| \n00092| ## The Architecture {: #the-architecture}\n00093| \n00094| Cloud backup is designed as a separate layer. Users start with a local master key and can enable cloud backup later.\n00095| \n00096| <img src=\"/images/posts/passkey-prf-architecture-light.svg\" alt=\"Architecture diagram showing local setup, cloud backup, and restore flows\" class=\"dark:hidden\">\n00097| <img src=\"/images/posts/passkey-prf-architecture-dark.svg\" alt=\"Architecture diagram showing local setup, cloud backup, and restore flows\" class=\"hidden dark:block\">\n00098| \n00099| ```markdown\n00100| ## LOCAL SETUP (no cloud):\n00101| \n00102| 1. First wallet creation generates random 32-byte master key\n00103| 2. Master key stored in local secure storage (Keychain/Keystore)\n00104| 3. Derive critical_data_key = HKDF(master_key, \"cspp:v1:critical\")\n00105| 4. Encrypt seed with critical_data_key\n00106| 5. (Optional) Derive sensitive_data_key = HKDF(master_key, \"cspp:v1:sensitive\")\n00107| 6. (Optional) Encrypt xpubs, wallet database, labels with sensitive_data_key\n00108| \n00109| ** User has no cloud backup, just their seed words **\n00110| \n00111| ## ENABLE CLOUD BACKUP:\n00112| \n00113| 1. User creates passkey for your wallet's backup domain\n00114| 2. App generates random 32-byte salt\n00115| 3. PRF(passkey, salt) -> prf_key\n00116| 4. Encrypt master_key with prf_key\n00117| 5. Upload encrypted master key + per-wallet backups to cloud\n00118| \n00119| ## RESTORE ON NEW DEVICE:\n00120| \n00121| 1. Fetch encrypted master key backup and wallet backups from cloud storage\n00122| 2. User authenticates with synced passkey\n00123| 3. PRF(passkey, salt) -> prf_key\n00124| 4. Decrypt master_key\n00125| 5. Derive critical_data_key\n00126| 6. Decrypt all wallet seeds\n00127| ```\n00128| \n00129| The key design decision is **decoupled storage**. The PRF protects the master key, but we store encrypted data separately in the user's own cloud storage (iCloud CloudKit on iOS, Google Drive appDataFolder on Android).\n00130| \n00131| This means:\n00132| \n00133| - No wallet servers ever see your data\n00134| - Users can verify their passkey exists in Settings → Passwords\n00135| - No size limitations (unlike WebAuthn's largeBlob extension)\n00136| - Cloud backup is opt-in, not required\n00137| \n00138| Each wallet is encrypted separately with its own nonce. Granular restore, independent wallet management, no single point of failure.\n00139| \n00140| ## Platform Support {: #platform-support}\n00141| \n00142| PRF is available on:\n00143| \n00144| - **iOS 18.4+ / macOS 15.4+** (iCloud Keychain passkeys) - minimum supported version\n00145| - **Android 9+** (Google Password Manager)\n00146| \n00147| The passkey syncs across devices through the platform's password manager. Same encryption key everywhere.\n00148| \n00149| **Warning: iOS 18.0-18.3 is not supported.** Apple announced PRF support<sup>[[4]]</sup> at WWDC 2024, but iOS 18.0-18.3 had a bug in Cross-Device Authentication (CDA) where PRF outputs varied depending on authentication method<sup>[[5]]</sup><sup>[[6]]</sup>, which could cause data loss for encrypted data. Users on iOS 18.0-18.3 must upgrade to iOS 18.4 or later before relying on PRF-based backups. Wallet implementations should check the iOS version and refuse to enable PRF backup on affected versions.\n00150| \n00151| This also explains why older wallets weren't using this approach. It only became viable recently. Before iOS 18.4, the only cross-platform option would have been largeBlob on iOS (introduced in iOS 17) and PRF on Android, requiring two different implementations. iOS 18.4 was released on March 31, 2025<sup>[[7]]</sup>. Now PRF works reliably on both platforms.\n00152| \n00153| ## Proposed Implementation {: #proposed-implementation}\n00154| \n00155| This section outlines my proposed technical details, which will serve as the basis for the formal specification. I'm tentatively calling it **CSPP** (Cove StashPay Passkey Protocol), though the name will probably change. These details are subject to change as we validate with real implementations.\n00156| \n00157| Cloud backup is opt-in. Users can start with local-only storage and enable or disable cloud backup later. This flexibility doesn't complicate the wallet's logic because the master key lives locally, independent of the passkey.\n00158| \n00159| ### Key Hierarchy\n00160| \n00161| ```text\n00162| MASTER KEY (32 bytes, random, generated on first wallet creation)\n00163| │\n00164| ├── Stored locally (never synced):\n00165| │   • iOS: Keychain with kSecAttrSynchronizable = false\n00166| │   • Android: Android Keystore (hardware-backed)\n00167| │\n00168| ├── CRITICAL DATA KEY = HKDF(master_key, \"cspp:v1:critical\")\n00169| │   └── For encrypting ALL seeds (single key for all wallets)\n00170| │\n00171| └── SENSITIVE DATA KEY = HKDF(master_key, \"cspp:v1:sensitive\")\n00172|     └── For encrypting ALL xpubs (single key for all xpubs)\n00173| ```\n00174| \n00175| We use a single key for all wallets rather than per-wallet derivation, trading some defense-in-depth for simplicity. ChaCha20-Poly1305 is secure as long as nonces aren't reused, and random 12-byte nonces make that effectively guaranteed. Implementations that prefer stronger compartmentalization can derive per-wallet keys using `HKDF(master_key, \"cspp:v1:critical:\" || wallet_id)`.\n00176| \n00177| When the user enables cloud backup, the master key is encrypted with the PRF-derived key and uploaded.\n00178| \n00179| ### Data Structures\n00180| \n00181| Two types of records are stored in the cloud. The Rust structs below illustrate the logical structure, but wire format and versioning will be defined in the formal spec.\n00182| \n00183| **Master Key Backup** (one per user):\n00184| \n00185| ```rust\n00186| pub struct EncryptedMasterKeyBackup {\n00187|     pub version: u32,              // format version (1)\n00188|     pub salt: [u8; 32],            // PRF salt (random, per-user)\n00189|     pub nonce: [u8; 12],           // ChaCha20 nonce\n00190|     pub ciphertext: Vec<u8>,       // encrypted master_key (32 bytes + auth tag)\n00191| }\n00192| ```\n00193| \n00194| This design assumes one passkey per user for the backup domain. Credential ID storage (for disambiguating multiple passkeys) will be addressed in the formal specification; for now, platform APIs handle credential lookup through `preferImmediatelyAvailableCredentials` on iOS and `getCredential()` on Android.\n00195| \n00196| **Wallet Backup** (one per wallet):\n00197| \n00198| ```rust\n00199| // Stored in cloud (unencrypted fields + encrypted payload)\n00200| pub struct EncryptedWalletBackup {\n00201|     pub version: u32,              // format version (1)\n00202|     pub wallet_id: String,         // app-level unique ID (e.g., UUID)\n00203|     pub nonce: [u8; 12],           // ChaCha20 nonce\n00204|     pub ciphertext: Vec<u8>,       // encrypted WalletEntry (below)\n00205| }\n00206| \n00207| // Plaintext payload (encrypted inside ciphertext)\n00208| pub struct WalletEntry {\n00209|     pub wallet_id: String,                 // app-level unique ID (e.g., UUID)\n00210|     pub secret: WalletSecret,              // Mnemonic | Descriptor | WatchOnly\n00211|     pub network: Network,                  // mainnet | testnet | signet\n00212|     pub name: Option<String>,              // user-facing wallet name\n00213|     pub master_fingerprint: Option<[u8; 4]>, // BIP32 master fingerprint\n00214|     pub derivation_path: Option<String>,   // e.g., \"m/84'/0'/0'\"\n00215|     pub extra: Option<Map<String, Value>>, // app-specific fields\n00216| }\n00217| \n00218| pub enum WalletSecret {\n00219|     Mnemonic(String),\n00220|     Descriptor(String),\n00221|     WatchOnly,\n00222| }\n00223| ```\n00224| \n00225| The `extra` field allows wallet developers to store app-specific metadata. This backup is primarily for seeds and is typically created once when the wallet is generated. Keep it to the minimum metadata needed for restoration.\n00226| \n00227| ### Encryption\n00228| \n00229| **Algorithm**: [ChaCha20-Poly1305](https://datatracker.ietf.org/doc/html/rfc8439) (AEAD)\n00230| \n00231| We chose ChaCha20-Poly1305 over AES-GCM for several reasons:\n00232| \n00233| - **Native mobile support** - Built into iOS (CryptoKit) and Android (javax.crypto) with no external dependencies\n00234| - **Software performance** - ChaCha20 is designed to be fast in pure software. While modern phones have AES hardware acceleration, ChaCha20 performs well even on older or budget devices without it\n00235| - **Constant-time by design** - Uses only add-rotate-xor operations, making it naturally resistant to timing side-channel attacks without special implementation care\n00236| - **Widely deployed** - Used in TLS 1.3, WireGuard, and Signal Protocol\n00237| \n00238| **PRF → Master Key Encryption**: The PRF output is used directly as the encryption key for the master key backup. No HKDF needed - the PRF output is already uniformly pseudorandom (it's HMAC output), and [RFC 5869](https://www.rfc-editor.org/rfc/rfc5869#section-3.3) explicitly allows skipping the extract step for such inputs.\n00239| \n00240| **Master Key → Derived Keys**: We use HKDF-SHA256 with info strings `\"cspp:v1:critical\"` and `\"cspp:v1:sensitive\"` for domain separation.\n00241| \n00242| ### Cloud Storage\n00243| \n00244| | Platform    | Storage                     | Notes                |\n00245| | ----------- | --------------------------- | -------------------- |\n00246| | **iOS**     | CloudKit (private database) | Hidden from user     |\n00247| | **Android** | Google Drive appDataFolder  | Hidden from Drive UI |\n00248| \n00249| Both are \"hidden\" storage - users can't accidentally browse to it and delete it. But since the data is encrypted, any storage works. Implementers can choose their own storage backend.\n00250| \n00251| ### Passkey Rotation\n00252| \n00253| One advantage of the master key architecture: if the user accidentally deletes their passkey, recovery is simple:\n00254| \n00255| 1. App detects passkey is missing (but master key exists locally)\n00256| 2. Create new passkey\n00257| 3. Generate new salt\n00258| 4. Encrypt local master key with new PRF-derived key\n00259| 5. Upload new `EncryptedMasterKeyBackup`\n00260| \n00261| Only one cloud record changes. Per-wallet backups stay the same because they're encrypted with keys derived from the master key, not the passkey.\n00262| \n00263| ### Backup Verification\n00264| \n00265| **iOS**: Using `preferImmediatelyAvailableCredentials`<sup>[[8]]</sup>, the app can silently detect if a passkey is missing - if no matching credentials exist, the request fails immediately without showing any UI<sup>[[9]]</sup>. This allows the app to detect a deleted passkey on startup without interrupting the user. However, actually verifying backup integrity (which requires a PRF operation to decrypt data) still requires biometric authentication.\n00266| \n00267| **Android**: Requires user interaction to verify the passkey. Credential Manager's `getCredential()` shows a bottom sheet UI<sup>[[10]]</sup>, and passkey operations require biometric or PIN verification<sup>[[11]]</sup>. We can turn this into a feature similar to Signal's periodic PIN verification - a \"Check Backup\" button that prompts biometric auth and verifies all backups are intact. This reinforces backup awareness rather than hiding it.\n00268| \n00269| ### Domain Binding\n00270| \n00271| The passkey's relying party should be a dedicated subdomain (e.g., `backup.yourwallet.app`), not the main app domain. This follows Trail of Bits' recommendation<sup>[[12]]</sup> from their Kraken Wallet audit. If the main domain is compromised, a dedicated backup domain limits the blast radius.\n00272| \n00273| This requires setting up domain association files:\n00274| \n00275| - iOS: `/.well-known/apple-app-site-association`\n00276| - Android: `/.well-known/assetlinks.json`\n00277| \n00278| ## Security Considerations {: #security-considerations}\n00279| \n00280| ### What This Protects Against\n00281| \n00282| **Cloud provider access** - Apple and Google only ever see encrypted blobs. Even if they wanted to, they cannot decrypt your seeds without your passkey. This is true regardless of whether Advanced Data Protection is enabled.\n00283| \n00284| **Cloud storage breach** - If an attacker compromises iCloud or Google Drive, they get ciphertext encrypted with ChaCha20-Poly1305. Without the PRF-derived key (which requires biometric auth on your device), the data is useless.\n00285| \n00286| **Phishing attacks** - The passkey is bound to your wallet's relying party domain. A phishing site on a different domain cannot trigger the PRF derivation, even if it looks identical to your wallet.\n00287| \n00288| **Server compromise** - There is no server. Your encrypted data lives in your own cloud storage. There's no central target for attackers.\n00289| \n00290| ### What This Doesn't Protect Against\n00291| \n00292| **Device compromise with unlocked passkey** - If malware has access to your device while it's unlocked and can trigger biometric auth (or the user approves a malicious prompt), the attacker could potentially derive the encryption key. This is the same threat model as any passkey-protected system.\n00293| \n00294| **Passkey provider compromise** - If Apple or Google's passkey sync infrastructure is compromised at a fundamental level, an attacker could theoretically access your PRF secret. This is an extreme scenario that would affect all passkey users globally.\n00295| \n00296| **User error** - If a user deletes their passkey AND loses all devices with the local master key, recovery is impossible without offline backups. Wallets should prominently warn users about this.\n00297| \n00298| ### Passkey Deletion Recovery\n00299| \n00300| If the user accidentally deletes their passkey but still has a device with the master key locally, recovery is straightforward:\n00301| \n00302| 1. App detects passkey is missing\n00303| 2. Create new passkey\n00304| 3. Generate new salt\n00305| 4. Re-encrypt master key with new PRF-derived key\n00306| 5. Upload new backup\n00307| \n00308| The user's wallet data is never at risk as long as one device retains the local master key.\n00309| \n00310| ### Recommended Mitigations\n00311| \n00312| **Seed word backup** - For users who want extra safety, wallets can offer the option to write down their BIP39 seed phrase. This also helps users get familiar with seed words for when they eventually move to hardware wallets, where writing them down is required.\n00313| \n00314| **Passkey status detection** - As mentioned in the Backup Verification section, iOS can silently detect a missing passkey using `preferImmediatelyAvailableCredentials`. Android requires user interaction for any passkey operation. The exact UX patterns for detecting deleted passkeys will likely be addressed in the formal specification.\n00315| \n00316| **Offline recovery kit** - An offline backup of the master key (encrypted with a user-chosen PIN and encoded as a printable format) could provide recovery even if both the passkey and all devices are lost. This is outside the scope of the current proposal but may be explored in a future version of the spec.\n00317| \n00318| ## What's Next {: #whats-next}\n00319| \n00320| Tankred and I plan to develop this into a formal specification. We'll be building implementations in Cove and StashPay to validate the approach before finalizing. The goal is a standard that any Bitcoin wallet can adopt, and if it gains traction, we may formalize it as a BIP.\n00321| \n00322| ## Feedback {: #feedback}\n00323| \n00324| This is an early proposal, and details will evolve as we develop the formal specification with real-world implementations. I'd love to hear from wallet developers, security researchers, and anyone thinking about this problem. What am I missing? What concerns do you have? Leave a comment below or reach out on [X](https://x.com/praveenperera). Interested in helping shape the spec? Reach out to [Tankred](https://x.com/tankredhase) or me.\n00325| \n00326| [1]: https://github.com/ACINQ/phoenix/blob/f3a227624c2ab262351a5261a5e4a1c6bdfc4887/phoenix-ios/phoenix-ios/sync/SyncSeedManager.swift\n00327| [2]: https://support.apple.com/guide/security/cloudkit-end-to-end-encryption-sec3cac31735/1/web/1\n00328| [3]: https://groups.google.com/a/chromium.org/g/blink-dev/c/guUJ9FuOIfc\n00329| [4]: https://webkit.org/blog/15443/news-from-wwdc24-webkit-in-safari-18-beta/\n00330| [5]: https://www.corbado.com/blog/passkeys-prf-webauthn\n00331| [6]: https://developer.apple.com/forums/thread/764730\n00332| [7]: https://support.apple.com/en-us/122371\n00333| [8]: https://developer.apple.com/documentation/authenticationservices/asauthorizationcontroller/requestoptions/preferimmediatelyavailablecredentials\n00334| [9]: https://developer.apple.com/forums/thread/737010\n00335| [10]: https://developer.android.com/identity/sign-in/credential-manager\n00336| [11]: https://developer.android.com/identity/passkeys\n00337| [12]: https://github.com/trailofbits/publications/blob/master/reviews/2024-09-kraken-mobile-wallet-icloud-backup-securityreview.pdf\n00338| \n\n(End of file - total 338 lines)\n</file>"}
{"type":"tool_use","timestamp":"2025-12-17T20:48:45.903Z","tool_name":"task","tool_input":{"subagent_type":"document-writer","description":"Review technical blog post","prompt":"TASK:\nReview the technical blog post at /Users/praveen/code/praveen/posts/2025/12-15-passkey-prf-bitcoin-wallet-backup.md and provide comprehensive feedback on its quality, clarity, technical accuracy, structure, and readability.\n\nEXPECTED OUTCOME:\nA detailed review covering:\n1. Overall assessment of the post's quality and effectiveness\n2. Strengths of the writing and technical explanations\n3. Areas for improvement in clarity, structure, or technical detail\n4. Suggestions for enhancing readability for both technical and less-technical audiences\n5. Any gaps in explanation or logical flow issues\n6. Specific recommendations for improvements with examples where applicable\n\nREQUIRED SKILLS:\n- Technical writing evaluation\n- Understanding of complex technical concepts (cryptography, authentication, mobile platforms)\n- Ability to assess both technical depth and accessibility\n- Document structure and flow analysis\n\nREQUIRED TOOLS:\n- read (to read the blog post file)\n\nMUST DO:\n- Read the entire blog post thoroughly\n- Evaluate the technical explanations for clarity and accuracy of presentation\n- Assess whether the progression from problem → existing solutions → proposed solution is effective\n- Check if the security considerations section adequately covers risks and mitigations\n- Evaluate whether code examples and data structures are well-explained\n- Consider the target audience (Bitcoin wallet developers, security researchers, technical users)\n- Provide specific, actionable feedback with examples\n- Note what works well in addition to areas for improvement\n- Consider the overall narrative flow and whether it builds understanding progressively\n\nMUST NOT DO:\n- Verify the technical correctness of cryptographic details (assume author's technical knowledge is sound)\n- Suggest major structural rewrites unless critically needed\n- Focus on minor grammar/style issues unless they impact clarity\n- Recommend adding content that would make the post significantly longer without clear benefit\n- Use tools beyond reading the file (no web searches, no external documentation lookups)\n\nCONTEXT:\nThis is a technical blog post proposing a new approach to Bitcoin wallet backup using WebAuthn PRF (Pseudo-Random Function) extension combined with cloud storage. The author (Praveen Perera) is building a Bitcoin wallet called Cove and is working with another developer (Tankred Hase) to formalize this into a specification. The post is meant to:\n1. Explain the problem with existing backup solutions\n2. Introduce the PRF-based architecture\n3. Provide enough technical detail for other wallet developers to understand and potentially implement\n4. Solicit feedback from the community before formalizing the spec\n\nThe post includes technical details like data structures (Rust code), encryption schemes, platform-specific considerations, and security tradeoffs. The target audience includes wallet developers, security researchers, and technically-minded Bitcoin users."}}
